https://segmentfault.com/a/1190000013662126#articleHeader46
###### 回流，重绘，浏览器渲染原理

###### visibility: hidden和display: none的区别
'''
可以如下回答：
普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置
进一步，display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大
再进一步，当一个页面某个元素经常需要切换display时如何优化，一般会用复合层优化，或者要求低一点用absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流，absolute文档流，复合图层的区别，
再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）
'''

###### 多线程的浏览器内核
每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程
'''
GUI线程
JS引擎线程
事件触发线程
定时器线程
网络请求线程
'''

######
'''
200——表明该请求被成功地完成，所请求的资源发送回客户端
304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
400——客户端请求有错（譬如可以是安全模块拦截）
401——请求未经授权
403——禁止访问（譬如可以是未登录时禁止）
404——资源未找到
500——服务器内部错误
503——服务不可用
'''

######什么会引起回流？
'''
1.页面渲染初始化

2.DOM结构改变，比如删除了某个节点

3.render树变化，比如减少了padding

4.窗口resize

5.最复杂的一种：获取某些属性，引发回流，
很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，
但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括
(1）offset(Top/Left/Width/Height)
(2) scroll(Top/Left/Width/Height)
(3) cilent(Top/Left/Width/Height)
(4) width,height
(5) 调用了getComputedStyle()或者IE的currentStyle

回流一定伴随着重绘，重绘却可以单独出现
所以一般会有一些优化方案，如：
减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新
避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document
避免多次读取offset等属性。无法避免则将它们缓存到变量
将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高
注意：改变字体大小会引发回流
'''

###### CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树


'''
如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）
如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列
'''

###### 作用域链
'''
它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。
譬如流程简述:
在函数上下文中，查找一个变量foo
如果函数的VO中找到了，就直接使用
否则去它的父级作用域链中（__parent__）找
如果父级中没找到，继续往上找
直到全局上下文中也没找到就报错
'''

###### this指针
'''
这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分
注意：this是执行上下文环境的一个属性，而不是某个变量对象的属性
因此:
this是没有一个类似搜寻变量的过程
当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻
this的值只取决中进入上下文时的情况
'''

###### 回收机制
'''
面试怎么回答
https://www.cnblogs.com/fundebug/p/javascript-memory-garbage-collection.html
1）问什么是垃圾
一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。
2）如何检垃圾
一种算法是标记 标记-清除 算法，还想说出不同的算法可以参考这里。
更深入一些的讲解 V8 之旅： 垃圾回收器
还有一种牛逼的答法就是说看我的博客，当然是要自己总结的博客。
'''

'''
JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。
一般来说，垃圾处理器有自己的回收策略。
譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）
常用的两种垃圾回收规则是：
标记清除
引用计数
Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），简单解释如下：
遍历所有可访问的对象。
回收已不可访问的对象。
譬如：（出自javascript高程）
当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。
从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
而当变量离开环境时，则将其标记为“离开环境”。
垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。
而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
关于引用计数，简单点理解：
跟踪记录每个值被引用的次数，当一个值被引用时，次数+1，减持时-1，下次垃圾回收器会回收次数为0的值的内存（当然了，容易出循环引用的bug）
GC的缺陷
和其他语言一样，javascript的GC策略也无法避免一个问题： GC时，停止响应其他操作
这是为了安全考虑。
而Javascript的GC在100ms甚至以上
对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。
这就是引擎需要优化的点： 避免GC造成的长时间停止响应。
GC优化策略
这里介绍常用到的：分代回收（Generation GC）
目的是通过区分“临时”与“持久”对象:
多回收“临时对象”区（young generation）
少回收“持久对象”区（tenured generation）
减少每次需遍历的对象，从而减少每次GC的耗时。
像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）
'''
###### 跨域-同源
'''
协议相同
域名相同
端口相同

同源政策规定，AJAX请求只能发给同源的网址，否则就报错。
除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。

JSONP: 网页通过添加<script></script>标签向服务端请求json数据,服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。JSONP只能发GET请求。
WebSocket: 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。
CORS: 跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的 请求。
对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。
对于非简单请求，"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。
'''

###### 计算一个元素在页面上到偏移量
1. 递归方法
'''
function getElementTop(elem) {
  let actualTop = elem.offsetTop;
  let currentParent = elem.offsetParent;
  while (current != null) {
    actualTop += currentParent.offsetTop;
    current = currentParent.offsetParent;
  }
  return actualTop;
}
'''
2. 使用scrollTop和getBoundingClientRect()
'''
function getElementTop(elem) {
  let rectElem = element.getBoundingClientRect();
  let actualTop = rectElem.top + document.body.scrollTop;
  return actualTop;
}
'''