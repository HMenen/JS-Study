##### 箭头函数与匿名函数的区别
箭头函数的this是由上下文决定的
匿名函数的this，是由调用者决定的

##### 和带名函数相比，匿名函数需要将地址赋值给另一个变量let a，然后再用a来调用函数；
和匿名函数比，箭头函数完全修复了this的指向，this总是指向词法作用域。

##### 自定义事件
1. let myEvement = new Event('clickTest');
2. element.addEventListener('clickTest', function() {...});
3. 注册事件：element.dispatchEvent(myEvement);

##### instanceof: 判断在一个实例对象的原型链上是否包含这个类的propertype属性
##### 闭包：在一个函数中可以访问另一个函数中的变量
##### 深拷贝和浅拷贝的区别
浅拷贝只拷贝了指向拷贝对象的指针，所以浅拷贝后改变其中的一个值会影响原对象的值  eg: Object.assign()
深拷贝是完全拷贝了一个对象，重新创建了一个新的对象，对其的值进行改变时，不会影响原对象的值
##### 清除浮动
```
overflow:hidden和clear:both
overflow用于父容器本身清除浮动,或者父容器内部元素溢出隐藏 
父容器和子容器,子容器float,会导致子容器跳出父容器,不仅是左右的浮动,更内外的立体浮动,所以此时给父容器
设置overflow:hidden,可以使父容器也浮动到同一层.
clear:both用于受到影响的容器,父包含块缩成一条时(没有设置宽高)，clear方法无用
overflow是用在浮动元素本身来清除对父元素的影响，clear：both；用在紧邻浮动元素来清除浮动影响

overflow: hidden
.clearfix：after {
    content: '';
    clear: both;
    height: 0;
    display: block;
    visibility: hidden;
}
```
##### 判断是否是一个数组： Array.isArray()
##### 数组求最大值
let arr = [2,77,45,78,1,2];
Math.max(...arr);

##### bind: 用来绑定上下文；强制的将函数的执行环境绑定到目标作用域上；返回的是一个函数。

##### 盒模型
```
标准盒模型
box-sizing: content-box;
ie盒模型
box-sizing: border-box;
```

##### 1.怎样添加、移除、移动、复制、创建和查找节点？
1. 创建
```
document.createElement();   //创建一个元素
document.createDocumentFragment()   //创建DOM片段
document.createTextNode()  //创建一个文本节点
```
2. 移除：removeChild  添加：appendChild  替换：replaceChild  插入：insertBefore
3. 查找
getElementsByTagName()  getElementsByName  getElementById   getElementByClassName

#####其它
1. 变量提升（变量的声明提前）：变量可以先使用再声明。
ie盒模型: 内容 + border + padding
标准盒模型: 内容
2. this：调用函数的那个对象。this永远指向函数运行时所在的对象。  
根据函数的调用方式的不同，this会指向不同的对象：【重要】  
1)以函数的形式调用，this为window；
2)以方法的形式调用，this为调用的对象；
3)构造函数的this，为构造出的对象；
4)以call、apply、bind的形式调用，this为指定的对象
3. 作用域：变量的作用范围
分类：全局作用域、函数作用域、块作用域（es6）
作用域是在定义的时候就已经确定的了，而不是在调用的时候确定的
4. 闭包
能够访问其他函数内的数据（变量、函数）的函数
如何产生闭包：
当一个嵌套的内部函数引用了嵌套的外部函数的变量和函数时，就产生了闭包
闭包的缺点及解决：
缺点：函数执行完成后，函数内部的局部变量没有马上释放，占用内存的时间增长，容易造成内存泄漏
解决：能不用闭包则不用，用完后一定要及时释放
5. Object.prototype.toString.call(this).slice(8, -1);
6. 立即执行函数
作用：防止变量污染
不破坏污染全局的命名空间，若需要使用，将其用变量传入如：(function(window) {})(window);
```
(function() {...})()
(function() {...}())
```
7. 505 （HTTP 版本不受支持）
8. 事件模型：捕获阶段、目标阶段、冒泡阶段
9. 字符串转为json对象
```
let str = '{ "name":"runoob", "alexa":10000, "site":"www.runoob.com" }';
JSON.parse(str);
eval('(' + str + ')')

json -> string
Json.tringfy()

var newstr = JSON.stringify(arr); //返回一个新字符串
JSON.parse(newstr);//字符串转json格式
```
10. 注意遍历时的key值类型为string
```
for(let i in obj) {console.log(typeof i)}
```
11. 将字符串转为整数的方法
```
let i = '1';
let j = '2';
console.log(i + j);    结果为：12
console.log(+i + +j)   结果为：3
console.log(~~i + ~~j)   结果为：3
console.log(parseInt(i) + parseInt(j))   结果为：3
```

##### amd、cmd区别
```
```

##### 作用域链
https://github.com/mqyqingfeng/Blog/issues/6
一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。
作用域链是在函数定义的时候创建的
##### set

##### new 做了什么
```
new 干了四件事
1.var obj={}；
2.obj.__proto__=test.prototype;
3.test.call(obj); 
4把obj的地址赋值给等式左边的变量
```

##### Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。
```
从浏览器中创建 XMLHttpRequests
从 node.js 创建 http 请求
支持 Promise API
拦截请求和响应
转换请求数据和响应数据
取消请求
自动转换 JSON 数据
客户端支持防御 XSRF

Ajax：
Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。
　　Ajax = 异步 JavaScript 和 XML（标准通用标记语言的子集）。
　　Ajax 是一种用于创建快速动态网页的技术。
　　Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。
　　通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
　　传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。
```

##### 描述以下变量的区别：null，undefined或undeclared
```
null 表示"没有对象"，即该处不应该有值，转为数值时为0。典型用法是：
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。
undefined 表示"缺少值"，就是此处应该有一个值，但是还没有定义，转为数值时为NaN。典型用法是：
（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。
undeclared :js语法错误，没有申明直接使用，js无法找到对应的上下文。
```

###### 常见的浏览器内核有哪些？
```
Trident 内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称 MSHTML]
Gecko 内核：Netscape6 及以上版本，FF,MozillaSuite/SeaMonkey 等
Presto 内核：Opera7 及以上。 [Opera 内核原为：Presto，现为：Blink;]
Webkit 内核：Safari,Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）]
```

##### for in, for of的特点
```
结合上面的两个例子,分析得出:
for ... in 循环返回的值都是数据结构的 键值名。
循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).

遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。
for ... in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。如——例3
特别情况下, for ... in 循环会以任意的顺序遍历键名
总结一句: for in 循环特别适合遍历对象。

数组的私有属性也会被遍历，所以一般我们不会用这个方法遍历数组

for of 特点
for of 循环用来获取一对键值对中的值,而 for in 获取的是 键名
一个数据结构只要部署了 Symbol.iterator 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。
例1这个对象,没有 Symbol.iterator这个属性,所以使用 for of会报 obj is not iterable
for of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。
提供了遍历所有数据结构的统一接口

不会遍历数组的私有属性，但是for of不能遍历对象（可以遍历字符串，数组对象）


使用Object.keys()遍历  
返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).

使用Object.getOwnPropertyNames(obj)遍历
返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性).

使用Reflect.ownKeys(obj)遍历
返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举.  
```

##### 属性类型
属性类型分为2种:数据属性和访问器属性
数据属性：
configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为true
enumerable:表示能否通过for-in循环返回属性
writable：表示能否修改属性的值
value：包含该属性的数据值。默认为undefined

访问器属性：
configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为false
enumerable:表示能否通过for-in循环返回属性,默认为false
Get：在读取属性时调用的函数,默认值为undefined
Set：在写入属性时调用的函数,默认值为undefined